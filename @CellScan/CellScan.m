classdef CellScan < ProcessedImg
%CellScan - Class to analyse cellular signals
%
%   The CellScan class analyses cellular signals, including identifying
%   regions of interest (ROIs) either manually or automatically, measuring
%   the levels and/or changes in signals, and classifying the signals.
%   Typically, the signal is generated by a fluorescent biosensor reporting
%   the level and/or change in a component of cellular physiology, using
%   either a dye or a genetically encoded sensor.
%
%   CellScan is a subclass of matlab.mixin.Copyable, which is itself a
%   subclass of handle, meaning that CellScan objects are actually
%   references to the data contained in the object. This ensures memory is
%   used efficiently when CellScan objects are contained in other objects
%   (e.g. ImgGroup objects). However, CellScan objects can use the copy
%   method of matlab.mixin.Copyable to create new, independent objects.
%
%   Please see the <a href="matlab:web(fullfile(utils.CHIPS_rootdir, 'doc', 'html', 'pi_CellScan.html'))">CellScan quick start guide</a> for additional documentation
%   and examples.
%
% CellScan public properties:
%   calcDetectSigs  - A scalar CalcDetectSigs object
%	calcFindROIs    - A scalar CalcFindROIs object
%	calcMeasureROIs - A scalar CalcMeasureROIs object
%	channelToUse    - The numeric index of the channel to use
%   name            - The object name
%   plotList        - The list of plot options for each Calc
%   rawImg          - A scalar RawImgHelper object
%   state           - The object state
% 
% CellScan public methods:
%   CellScan        - CellScan class constructor
%   calc_combined_mask - Calculate a combined mask from a CellScan array
%   combine_masks   - Combine and replace masks in a CellScan array
%   copy            - Copy MATLAB array of handle objects
%   get_config      - Return the Config from this CellScan object
%   get_refImg      - Return a reference image of the field of view
%   opt_config      - Optimise the parameters in Config objects using a GUI
%   output_data     - Output the data
%   plot            - Plot a figure
%   process         - Process the elements of the CellScan object
%
% CellScan static methods:
%   reqChannelAll   - The rawImg requires all of these channels
%   reqChannelAny   - The rawImg requires at least one of these channels
%
% CellScan public events:
%   NewRawImg       - Notifies listeners that the rawImg property was set
%
%   See also CellScan/CellScan, ProcessedImg, matlab.mixin.Copyable,
%   IRawImg, RawImgHelper, CalcFindROIs, CalcMeasureROIs, CalcDetectSigs

%   Copyright (C) 2017  Matthew J.P. Barrett, Kim David Ferrari et al.
%
%   This program is free software: you can redistribute it and/or modify
%   it under the terms of the GNU General Public License as published by
%   the Free Software Foundation, either version 3 of the License, or
%   (at your option) any later version.
% 
%   This program is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%   GNU General Public License for more details.
%   
%   You should have received a copy of the GNU General Public License 
%   along with this program.  If not, see <http://www.gnu.org/licenses/>.  
    
    % ================================================================== %
    
    properties
        
        %calcFindROIs - A scalar CalcFindROIs object
        %
        %   The scalar object must be of any subclass derived from
        %   CalcFindROIs and thereby determines the used methods to
        %   identify regions of interest. So far the classes to be used can
        %   be either CalcFindROIsFLIKA or CalcFindROIsDummy.
        %
        %   See also CalcFindROIs, CalcFindROIsFLIKA, CalcFindROIsDummy,
        %   CellScan/CellScan
        calcFindROIs
        
        %calcMeasureROIs - A scalar CalcMeasureROIs object
        %
        %   The scalar object must be of any subclass derived from
        %   CalcMeasureROIs and thereby determines the used methods to
        %   measure signals in previously identified regions of interest.
        %   So far the classes to be used can be either
        %   CalcFindMeasureROIsClsfy or CalcMeasureROIsDummy.
        %
        %   See also CalcMeasureROIs, CalcMeasureROIsMovingBL,
        %   CalcMeasureROIsZScore, CalcMeasureROIsDummy, CellScan/CellScan
        calcMeasureROIs
        
        %calcDetectSigs - A scalar CalcDetectSigs object
        %
        %   The scalar object must be of any subclass derived from
        %   CalcDetectSigs and thereby determines the used methods to
        %   detect (and in some cases) classify signals. So far the classes
        %   to be used can be either CalcDetectSigsDummy or
        %   CalcDetectSigsClsfy.
        %
        %   See also CalcDetectSigs, CalcDetectSigsDummy,
        %   CalcDetectSigsClsfy, CellScan/CellScan
        calcDetectSigs
        
        %channelToUse - The numeric index of the channel to use
        %
        %   The numeric index of the channel to use for ROI identification
        %   and signal measurement.
        %
        %   See also CalcMeasureROIs, CalcFindMeasureROIsClsfy,
        %   CalcMeasureROIsDummy, CellScan/CellScan
        channelToUse
        
    end
    
    % ------------------------------------------------------------------ %
    
    properties (Constant)
        
        %plotList - The list of plot options for each Calc
        plotList = struct(...
            'calcFindROIs', {{'default', 'images', 'rois', 'video', ...
                'pc_filters', 'pc_spectrum', 'ica_traces'}}, ...
            'calcMeasureROIs', {{'default', 'traces'}}, ...
            'calcDetectSigs', {{'default', 'signals', 'classification'}});
        
    end
    
    % ================================================================== %
    
    methods
        
        function CellScanObj = CellScan(varargin)
        %CellScan - CellScan class constructor
        % 
        %   OBJ = CellScan() constructs a CellScan object, prompting for
        %   any information that is required.
        %
        %   OBJ = CellScan(NAME, RAWIMG, CONFIG, CHANNEL) constructs a
        %   CellScan object, specifying the object name (NAME), one or more
        %   raw images (RAWIMG), a config object (CONFIG), and the CHANNEL
        %   to use when finding and measuring ROIs.
        %
        %   Any of the arguments can be replaced by [] to prompt for the
        %   required information.
        %
        %   NAME must be a single row character array.
        %   RAWIMG must be an object derived from the RawImg class, and can
        %   be any shape.  However, the resulting CellScan object will
        %   be of size [1, numel(RAWIMG)].
        %   CONFIG must be a scalar object from the ConfigCellScan class,
        %   containing three scalar objects derived from the Config class.
        %   Their create_calc() must return an object each from the 
        %   CalcFindROIs, CalcMeasureROIs, and CalcDetectSigs class.
        %   CHANNEL must be an integer value representing the index of the
        %   channel to be used.
        %
        %   If RAWIMG is not scalar, the values for the other arguments are
        %   assumed to apply to all elements of RAWIMG.  This is true
        %   whether the arguments are specified explicitly, or implicitly
        %   (i.e. via interactive prompt).  To choose or specify individual
        %   values for the other arguments, either create the CellScan
        %   objects individually and combine into an array, or use the
        %   ImgGroup class.
        %
        %   Please see the <a href="matlab:web(fullfile(utils.CHIPS_rootdir, 'doc', 'html', 'pi_CellScan.html'))">CellScan quick start guide</a> for additional
        %   documentation and examples.
        %
        %   See also CongfigCellScan, CalcFindROIs, CalcMeasureROIs,
        %   CalcDetectSigs, ProcessedImg, ImgGroup
        
            % Parse arguments
            [name, rawImg, configCSIn, channelToUseIn] = ...
                utils.parse_opt_args({'', [], [], [], []}, varargin);
            
            % Call RawImg (i.e. parent class) constructor
            CellScanObj = CellScanObj@ProcessedImg(name, rawImg);
            
            % Work out the current recursion depth
            if utils.is_deeper_than('CellScan.CellScan')
                return;
            end
            
            % Sort out the config
            configFindIn = [];
            configMeasureIn = [];
            configDetectIn = [];
            hasConfig = ~isempty(configCSIn);
            if hasConfig

                isGoodConfig = isa(configCSIn, 'ConfigCellScan');
                if ~isGoodConfig
                    error('CellScan:WrongClassConfig', ['The config '...
                        'must be of class "ConfigCellScan", whereas ' ...
                        'the supplied config is of class "%s"'], ...
                        class(configCSIn))
                end
                
                if ~isscalar(configCSIn)
                    error('CellScan:NonScalarConfig', ...
                        'The config must be a scalar.')
                end

                configFindIn = configCSIn.configFindROIs;
                configMeasureIn = configCSIn.configMeasureROIs;
                configDetectIn = configCSIn.configDetectSigs;

            end

            % Choose which channel to process
            if isempty(channelToUseIn)
                channelToUseIn = CellScanObj.choose_channel();
            end
            [CellScanObj(:).channelToUse] = deal(channelToUseIn);
            
            % Work out the name of the channel we'd like to use
            chName = CellScanObj(1).rawImg.get_ch_name(channelToUseIn);
            chName = chName{1};
            
            % Choose which ROI finding method, assuming all images are the
            % same as the first
            if isempty(configFindIn)
                nx = CellScanObj(1).rawImg.metadata.nLinesPerFrame;
                ny = CellScanObj(1).rawImg.metadata.nPixelsPerLine;
                calcObjFind = CellScan.choose_calcFindROIs(chName, nx, ny);
            else
                calcObjFind = configFindIn.create_calc();
            end
            for iElem = 1:numel(CellScanObj)
                CellScanObj(iElem).calcFindROIs = copy(calcObjFind);
            end
            
            % Choose which ROI measurement method
            if isempty(configMeasureIn)
                calcObjMeasure = CellScan.choose_calcMeasureROIs(chName);
            else
                calcObjMeasure = configMeasureIn.create_calc();
            end
            for iElem = 1:numel(CellScanObj)
                CellScanObj(iElem).calcMeasureROIs = copy(calcObjMeasure);
            end
            
            % Choose which Signal detection method
            if isempty(configDetectIn)
                calcObjDetect = CellScan.choose_calcDetectSigs(chName);
            else
                calcObjDetect = configDetectIn.create_calc();
            end
            for iElem = 1:numel(CellScanObj)
                CellScanObj(iElem).calcDetectSigs = copy(calcObjDetect);
            end
            
        end
        
        % -------------------------------------------------------------- %
        
        maskCombined = calc_combined_mask(self, varargin)
        
        % -------------------------------------------------------------- %
        
        varargout = combine_masks(self, varargin)
        
        % -------------------------------------------------------------- %
        
        function configOut = get_config(self)
        %get_config - Return the Config from this CellScan object
        %
        %   CONFIG = get_config(OBJ) returns the ConfigCellScan object
        %   associated with this CellScan object.  If the CellScan object
        %   is non-scalar, CONFIG will be an array of length numel(OBJ).
        %
        %   See also ConfigCellScan, Config
        
            % Call the function one by one if we have an array
            if ~isscalar(self)
                configOut = arrayfun(@(xx) get_config(xx), self, ...
                    'UniformOutput', false);
                configOut = [configOut{:}];
                return
            end
            
            % Assemble the config object
            configOut = ConfigCellScan(self.calcFindROIs.config, ...
                self.calcMeasureROIs.config, ...
                self.calcDetectSigs.config);
            
        end
        
        % -------------------------------------------------------------- %
        
        function [refImg, varargout] = get_refImg(self, varargin)
        %get_refImg - Return a reference image of the field of view
        %
        %   REF_IMG = get_refImg(OBJ) produces a reference image for the
        %   CellScan object OBJ.  At this time get_refImg is only valid for
        %   scalar CellScan objects.
        %
        %   REF_IMG = get_refImg(..., 'attribute', value, ...) uses the
        %   specified attribute/value pairs.  Valid attributes (case
        %   insensitive) are:
        %
        %       'FrameNum' ->   The (scalar, integer) frame number of the
        %                       raw image to display as a reference image.
        %                       If empty, the average of all frames is
        %                       used. [default = []]
        %
        %   See also CellScan.plot
        
            % Setup the default parameter names and values
            pNames = {
                'FrameNum'
                };
            pValues = {
                []
                };
            dflts = cell2struct(pValues, pNames);
            params = utils.parse_params(dflts, varargin{:});
            
            % Check it's a scalar object
            utils.checks.scalar(self, 'CellScan object')
            
            % Produce a reference image to use in the plots
            [isLS, refImg] = self.calcFindROIs.get_LS(self);
            if isLS
                refImg = squeeze(refImg)';
            else
                if isempty(params.FrameNum)
                    refImg = utils.nansuite.nanmean(...
                        self.rawImg.rawdata(:,:,self.channelToUse, :), 4);
                else
                    
                    % Check the frame number
                    utils.checks.prfsi(params.FrameNum)
                    nFrames = self.rawImg.metadata.nFrames;
                    allowEq = true;
                    utils.checks.less_than(params.FrameNum, nFrames, ...
                        allowEq, 'frameNum')
                    
                    % Produce the reference image
                    refImg = self.rawImg.rawdata(:,:,...
                        self.channelToUse, params.FrameNum);
                end
            end
            
            varargout{1} = isLS;
            
        end
        
        % -------------------------------------------------------------- %
        
        varargout = plot(self, varargin)
        
        % -------------------------------------------------------------- %
        
        function set.calcDetectSigs(self, calcDetectSigs)
            
            % Check it's the right class
            className = 'CalcDetectSigs';
            varName = 'calcDetectSigs';
            utils.checks.object_class(calcDetectSigs, className, varName);
            
            % Check calcROIs is scalar
            utils.checks.scalar(calcDetectSigs, varName);
            
            % Set the property
            self.calcDetectSigs = calcDetectSigs;
            
        end
        
        % -------------------------------------------------------------- %
        
        function set.calcFindROIs(self, calcFindROIs)
            
            % Check it's the right class
            className = 'CalcFindROIs';
            varName = 'calcFindROIs';
            utils.checks.object_class(calcFindROIs, className, varName);
            
            % Check calcROIs is scalar
            utils.checks.scalar(calcFindROIs, varName);
            
            % Set the property
            self.calcFindROIs = calcFindROIs;
            
        end
        
        % -------------------------------------------------------------- %
        
        function set.calcMeasureROIs(self, calcMeasureROIs)
            
            % Check it's the right class
            className = 'CalcMeasureROIs';
            varName = 'calcMeasureROIs';
            utils.checks.object_class(calcMeasureROIs, className, varName);
            
            % Check calcROIs is scalar
            utils.checks.scalar(calcMeasureROIs, varName);
            
            % Set the property
            self.calcMeasureROIs = calcMeasureROIs;
            
        end
        
        % -------------------------------------------------------------- %
        
        function set.channelToUse(self, channelToUse)
            
            % Check that required properties exist before continuing. This
            % will prevent errors on loading from saved (e.g. in parfor)
            if ~isprop(self, 'rawImg') || ~isprop(self, 'reqChannelAny') ...
                    || isempty(self.rawImg) || isempty(self.reqChannelAny)
                
                % Set the property anyways
                self.channelToUse = channelToUse;
                
                return
            end

            % Check that the input is in correct format
            if ~isnumeric(channelToUse) || ~isreal(channelToUse) ...
                    || channelToUse < 1 || ~isscalar(channelToUse)
                
                error('CellScan:InvalidChannelFormat', ['Specified ', ...
                    'channel name is in wrong format. Use the ', ...
                    'corresponding channel index in the image array'])
                
            end
            
            % Check that the channel exists
            nChannels = self.rawImg.metadata.nChannels;
            
            if channelToUse > nChannels
                error('CellScan:InvalidChannelNumber', ['Specified', ...
                    sprintf(' channel (%1d) doesn''t exist.', ...
                    channelToUseIn)])
            end
            
            % Check that the channel is one of the sort we can actually
            % process (e.g. RCaMP/GCaMP etc)
            
            chanStruct = self.rawImg.metadata.channels;
            cc = struct2cell(chanStruct);
            chIdx = [cc{:}] == channelToUse;
            channelNames = fieldnames(chanStruct);
            chosenChannel = channelNames{chIdx};
            
            goodChannel = find(ismember(self.reqChannelAny,chosenChannel));
            
            if ~goodChannel
                strChs = sprintf('%s ', self.reqChannelAny{:});
                strChs = strChs(1:end-1);
                error('CellScan:BadChannel', ['Specified channel (%s) ' ...
                    'can''t be used for ROI identification. Please ' ...
                    'use one of the following: %s'], chosenChannel, ...
                    strChs)
            end
            
            % Set the property
            self.channelToUse = channelToUse;
            
        end
        
    end
    
    % ================================================================== %
    
    methods (Access=protected)
        
        varargout = plot_main(self, hFig, varargin)
        
        % -------------------------------------------------------------- %
        
        plot_traces(self, varargin)
        
        % -------------------------------------------------------------- %
        
        process_sub(self, varargin)
        
        % -------------------------------------------------------------- %
        
        function find_ROIs(self)
            
            % Call the findROIs method of the calc object    
            self.calcFindROIs = self.calcFindROIs.process(self);
            
        end
        
        % -------------------------------------------------------------- %
        
        function measure_ROIs(self)
            
            % Call the measureROIs method of the calc object
            self.calcMeasureROIs = self.calcMeasureROIs.process(self);
            
        end
        
        % -------------------------------------------------------------- %
        
        function detect_sigs(self)
            
            % Call the findROIs method of the calc object    
            self.calcDetectSigs = self.calcDetectSigs.process(self);
            
        end
        
        % -------------------------------------------------------------- %
        
        function varargout = plot_signals(self, varargin)
            
            % Setup the default parameter names and values
            pNames = {
                    'plotROIs' ...
                    };
                pValues = {
                    [] ...
                    };
            dflts = cell2struct(pValues, pNames);
            params = utils.parse_params(dflts, varargin{:});
            
            % Get the plotROIs
            params.plotROIs = self.calcMeasureROIs.get_plotROIs(...
                params.plotROIs);
            
            % Call the calcDetectSigs to do most of the work
            hFig = self.calcDetectSigs.plot(self, 'signals', params);
            
            % Setup the output arguments
            if nargout > 0
                varargout{1} = hFig;
            end
            
        end
        
        % -------------------------------------------------------------- %
        
        function update_rawImg_props(self)
            
            % Call the superclass method to do it's bit
            self.update_rawImg_props@ProcessedImg()
            
            % Call the function one by one if we have an array
            if ~isscalar(self)
                arrayfun(@update_rawImg_props, self);
                return
            end
            
        end
        
    end
    
    % ================================================================== %
    
    methods (Static)
        
        function chList = reqChannelAll()
        %reqChannelAl - The rawImg requires all of these channels
            chList = {};
        end
        
        % -------------------------------------------------------------- %
        
        function chList = reqChannelAny()
        %reqChannelAny - The rawImg requires at least one of these channels
            chList = {'Ca_Cyto_Astro', 'Ca_Memb_Astro', ...
            'Ca_Neuron', 'cellular_signal', 'FRET_ratio'};
        end
        
    end
    
    % ================================================================== %
    
    methods (Static, Access = protected)
        
        function calcFindROIs = choose_calcFindROIs(varargin)
            
            % Parse arguments
            [channelToUseIn, nx, ny] = utils.parse_opt_args(...
                {'', 256, 256}, varargin);
            
            listMethods = {...
                'whole frame', ...
                'load ImageJ ROIs', ...
                'load mask from .tif or .mat file', ...
                '2D FLIKA (automatic ROI selection)', ...
                '2.5D FLIKA (automatic ROI selection)', ...
                '3D FLIKA (automatic ROI selection)',...
                'CellSort (automatic ROI selection)'
                };
            
            % Choose method to find ROIs
            strTitle = ...
                'Which ROI detection method would you like to use?';
            imgOptions = [{''},listMethods];
            defOption = 1;
            methodNum = utils.txtmenu({strTitle, ...
                'Select a detection method, please:'}, ...
                defOption, imgOptions);
            
            % Select corresponding method and create the config
            switch methodNum
                case 1
                    
                    configIn = ConfigFindROIsDummy();
                    
                case 2
                    
                    configIn = ConfigFindROIsDummy.from_ImageJ([], nx, ny);
                    
                case 3
                    
                    configIn = ConfigFindROIsDummy.from_mask();
                    
                case 4
                    
                    % Use the channel if it is supplied
                    wngState = warning('off', ...
                        'ConfigFindROIsFLIKA:FromPreset:UnknownPreset');
                    configIn = ConfigFindROIsFLIKA_2D.from_preset(...
                        channelToUseIn);
                    warning(wngState)
                    
                case 5
                    
                    % Use the channel if it is supplied
                    wngState = warning('off', ...
                        'ConfigFindROIsFLIKA:FromPreset:UnknownPreset');
                    configIn = ConfigFindROIsFLIKA_2p5D.from_preset(...
                        channelToUseIn);
                    warning(wngState)
                    
                case 6
                    
                    % Use the channel if it is supplied
                    wngState = warning('off', ...
                        'ConfigFindROIsFLIKA:FromPreset:UnknownPreset');
                    configIn = ConfigFindROIsFLIKA_3D.from_preset(...
                        channelToUseIn);
                    warning(wngState)
                    
                case 7
                    
                    % Use the channel if it is supplied;
                    configIn = ConfigFindROIsCellSort();
                    
                otherwise
                    
                    error('CellScan:ChooseCalcFindROIs:error', ...
                        'This should not have happened!')
                    
            end
            
            % Create the calc object from the config
            calcFindROIs = configIn.create_calc();
            
        end
        
        % -------------------------------------------------------------- %
        
        function calcMeasureROIs = choose_calcMeasureROIs(varargin)
            
            % Parse arguments            
            listMethods = {...
                'simple baseline normalised'
                };
            
            % Choose method to find ROIs
            strTitle = ...
                'Which ROI measuring method would you like to use?';
            imgOptions = [{''}, listMethods];
            defOption = 1;
            methodNum = utils.txtmenu({strTitle, ...
                'Select a measuring method, please:'}, ...
                defOption, imgOptions);
            
            % Select corresponding method and create the config
            switch methodNum
                case 1
                    
                    configIn = ConfigMeasureROIsDummy();
                    
                otherwise
                    
                    error('CellScan:ChooseCalcMeasureROIs:error', ...
                        'This should not have happened!')
                    
            end
            
            % Create the calc object from the config
            calcMeasureROIs = configIn.create_calc();
            
        end
        
        % -------------------------------------------------------------- %
        
        function calcDetectSigs = choose_calcDetectSigs(varargin)
            
            % Parse arguments            
            listMethods = {...
                'no signal detection', ...
                'detect + classify signals', ...
                };
            
            % Choose method to find ROIs
            strTitle = ...
                'Which signal detection method would you like to use?';
            imgOptions = [{''}, listMethods];
            defOption = 1;
            methodNum = utils.txtmenu({strTitle, ...
                'Select a detection method, please:'}, ...
                defOption, imgOptions);
            
            % Select corresponding method and create the config
            switch methodNum
                case 1
                    
                    configIn = ConfigDetectSigsDummy();
                    
                case 2
                    
                    configIn = ConfigDetectSigsClsfy();
                    
                otherwise
                    
                    error('CellScan:ChooseCalcDetectSignals:error', ...
                        'This should not have happened!')
                    
            end
            
            % Create the calc object from the config
            calcDetectSigs = configIn.create_calc();
            
        end
        
        % -------------------------------------------------------------- %
        
        function objOut = loadobj(structIn)
        %loadobj - Overload the loadobj method for CellScan objects
            
            % Create the basic object, which also attaches the listener
            configCS = ConfigCellScan(structIn.calcFindROIs.config, ...
                structIn.calcMeasureROIs.config, ...
                structIn.calcDetectSigs.config);
            objOut = CellScan(structIn.name_sub, structIn.rawImg, ...
                configCS, structIn.channelToUse);
            
            % Update the calcs to ensure any data is also loaded
            objOut.calcFindROIs = structIn.calcFindROIs;
            objOut.calcMeasureROIs = structIn.calcMeasureROIs;
            objOut.calcDetectSigs = structIn.calcDetectSigs;
            
            % Update the remaining properties
            if ~isempty(structIn.refImg)
                objOut.refImg = structIn.refImg;
            end
            
        end
        
    end
    
    % ================================================================== %
    
end
